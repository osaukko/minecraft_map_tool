use image::Rgba;
use std::collections::HashMap;

pub type Palette = HashMap<u8, Rgba<u8>>;

pub fn generate() -> Palette {
    let base_colors = Palette::from([
        (0, Rgba([0, 0, 0, 0])),
        (1, Rgba([127, 178, 56, 255])),
        (2, Rgba([247, 233, 163, 255])),
        (3, Rgba([199, 199, 199, 255])),
        (4, Rgba([255, 0, 0, 255])),
        (5, Rgba([160, 160, 255, 255])),
        (6, Rgba([167, 167, 167, 255])),
        (7, Rgba([0, 124, 0, 255])),
        (8, Rgba([255, 255, 255, 255])),
        (9, Rgba([164, 168, 184, 255])),
        (10, Rgba([151, 109, 77, 255])),
        (11, Rgba([112, 112, 112, 255])),
        (12, Rgba([64, 64, 255, 255])),
        (13, Rgba([143, 119, 72, 255])),
        (14, Rgba([255, 252, 245, 255])),
        (15, Rgba([216, 127, 51, 255])),
        (16, Rgba([178, 76, 216, 255])),
        (17, Rgba([102, 153, 216, 255])),
        (18, Rgba([229, 229, 51, 255])),
        (19, Rgba([127, 204, 25, 255])),
        (20, Rgba([242, 127, 165, 255])),
        (21, Rgba([76, 76, 76, 255])),
        (22, Rgba([153, 153, 153, 255])),
        (23, Rgba([76, 127, 153, 255])),
        (24, Rgba([127, 63, 178, 255])),
        (25, Rgba([51, 76, 178, 255])),
        (26, Rgba([102, 76, 51, 255])),
        (27, Rgba([102, 127, 51, 255])),
        (28, Rgba([153, 51, 51, 255])),
        (29, Rgba([25, 25, 25, 255])),
        (30, Rgba([250, 238, 77, 255])),
        (31, Rgba([92, 219, 213, 255])),
        (32, Rgba([74, 128, 255, 255])),
        (33, Rgba([0, 217, 58, 255])),
        (34, Rgba([129, 86, 49, 255])),
        (35, Rgba([112, 2, 0, 255])),
        (36, Rgba([209, 177, 161, 255])),
        (37, Rgba([159, 82, 36, 255])),
        (38, Rgba([149, 87, 108, 255])),
        (39, Rgba([112, 108, 138, 255])),
        (40, Rgba([186, 133, 36, 255])),
        (41, Rgba([103, 117, 53, 255])),
        (42, Rgba([160, 77, 78, 255])),
        (43, Rgba([57, 41, 35, 255])),
        (44, Rgba([135, 107, 98, 255])),
        (45, Rgba([87, 92, 92, 255])),
        (46, Rgba([122, 73, 88, 255])),
        (47, Rgba([76, 62, 92, 255])),
        (48, Rgba([76, 50, 35, 255])),
        (49, Rgba([76, 82, 42, 255])),
        (50, Rgba([142, 60, 46, 255])),
        (51, Rgba([37, 22, 16, 255])),
        (52, Rgba([189, 48, 49, 255])),
        (53, Rgba([148, 63, 97, 255])),
        (54, Rgba([92, 25, 29, 255])),
        (55, Rgba([22, 126, 134, 255])),
        (56, Rgba([58, 142, 140, 255])),
        (57, Rgba([86, 44, 62, 255])),
        (58, Rgba([20, 180, 133, 255])),
        (59, Rgba([100, 100, 100, 255])),
        (60, Rgba([216, 175, 147, 255])),
        (61, Rgba([127, 167, 150, 255])),
    ]);

    let mut palette = Palette::new();
    for id in 0..62u8 {
        let (r, g, b, a) = match base_colors.get(&id) {
            None => (0, 0, 0, 0),
            Some(Rgba([r, g, b, a])) => (*r as i32, *g as i32, *b as i32, *a),
        };
        palette.insert(
            id * 4,
            Rgba([
                ((r * 180) / 255) as u8,
                ((g * 180) / 255) as u8,
                ((b * 180) / 255) as u8,
                a,
            ]),
        );
        palette.insert(
            id * 4 + 1,
            Rgba([
                ((r * 220) / 255) as u8,
                ((g * 220) / 255) as u8,
                ((b * 220) / 255) as u8,
                a,
            ]),
        );
        palette.insert(
            id * 4 + 2,
            Rgba([
                ((r * 255) / 255) as u8,
                ((g * 255) / 255) as u8,
                ((b * 255) / 255) as u8,
                a,
            ]),
        );
        palette.insert(
            id * 4 + 3,
            Rgba([
                ((r * 135) / 255) as u8,
                ((g * 135) / 255) as u8,
                ((b * 135) / 255) as u8,
                a,
            ]),
        );
    }
    palette
}
